// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CrossCheatTalkMessages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CrossCheatTalkMessages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* VectorMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VectorMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* CrossCheatInitMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CrossCheatInitMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* EntityPacketMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EntityPacketMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExploitOnMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExploitOnMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* SharedESPUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SharedESPUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* HitBoxMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HitBoxMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* OriginUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OriginUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* HarpoonChat_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HarpoonChat_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CrossCheatMsgType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_CrossCheatTalkMessages_2eproto() {
  protobuf_AddDesc_CrossCheatTalkMessages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CrossCheatTalkMessages.proto");
  GOOGLE_CHECK(file != NULL);
  VectorMsg_descriptor_ = file->message_type(0);
  static const int VectorMsg_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMsg, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMsg, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMsg, z_),
  };
  VectorMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VectorMsg_descriptor_,
      VectorMsg::default_instance_,
      VectorMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VectorMsg));
  CrossCheatInitMsg_descriptor_ = file->message_type(1);
  static const int CrossCheatInitMsg_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossCheatInitMsg, steamid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossCheatInitMsg, steamindex_),
  };
  CrossCheatInitMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CrossCheatInitMsg_descriptor_,
      CrossCheatInitMsg::default_instance_,
      CrossCheatInitMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossCheatInitMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossCheatInitMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CrossCheatInitMsg));
  EntityPacketMsg_descriptor_ = file->message_type(2);
  static const int EntityPacketMsg_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, steamid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, serverindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, playerhealth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, playerarmour_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, matrixdata_),
  };
  EntityPacketMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EntityPacketMsg_descriptor_,
      EntityPacketMsg::default_instance_,
      EntityPacketMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityPacketMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EntityPacketMsg));
  ExploitOnMsg_descriptor_ = file->message_type(3);
  static const int ExploitOnMsg_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExploitOnMsg, on_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExploitOnMsg, speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExploitOnMsg, tickstarted_),
  };
  ExploitOnMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExploitOnMsg_descriptor_,
      ExploitOnMsg::default_instance_,
      ExploitOnMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExploitOnMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExploitOnMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExploitOnMsg));
  SharedESPUpdate_descriptor_ = file->message_type(4);
  static const int SharedESPUpdate_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedESPUpdate, entinfo_),
  };
  SharedESPUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SharedESPUpdate_descriptor_,
      SharedESPUpdate::default_instance_,
      SharedESPUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedESPUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedESPUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SharedESPUpdate));
  HitBoxMsg_descriptor_ = file->message_type(5);
  static const int HitBoxMsg_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HitBoxMsg, mins_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HitBoxMsg, maxs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HitBoxMsg, bone_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HitBoxMsg, radius_),
  };
  HitBoxMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HitBoxMsg_descriptor_,
      HitBoxMsg::default_instance_,
      HitBoxMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HitBoxMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HitBoxMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HitBoxMsg));
  OriginUpdate_descriptor_ = file->message_type(6);
  static const int OriginUpdate_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginUpdate, steamid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginUpdate, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginUpdate, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginUpdate, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginUpdate, eyeangles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginUpdate, eyeposition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginUpdate, matrix_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginUpdate, hitboxes_),
  };
  OriginUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OriginUpdate_descriptor_,
      OriginUpdate::default_instance_,
      OriginUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OriginUpdate));
  HarpoonChat_descriptor_ = file->message_type(7);
  static const int HarpoonChat_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HarpoonChat, steamid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HarpoonChat, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HarpoonChat, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HarpoonChat, text_),
  };
  HarpoonChat_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HarpoonChat_descriptor_,
      HarpoonChat::default_instance_,
      HarpoonChat_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HarpoonChat, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HarpoonChat, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HarpoonChat));
  CrossCheatMsgType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CrossCheatTalkMessages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VectorMsg_descriptor_, &VectorMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CrossCheatInitMsg_descriptor_, &CrossCheatInitMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EntityPacketMsg_descriptor_, &EntityPacketMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExploitOnMsg_descriptor_, &ExploitOnMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SharedESPUpdate_descriptor_, &SharedESPUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HitBoxMsg_descriptor_, &HitBoxMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OriginUpdate_descriptor_, &OriginUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HarpoonChat_descriptor_, &HarpoonChat::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CrossCheatTalkMessages_2eproto() {
  delete VectorMsg::default_instance_;
  delete VectorMsg_reflection_;
  delete CrossCheatInitMsg::default_instance_;
  delete CrossCheatInitMsg_reflection_;
  delete EntityPacketMsg::default_instance_;
  delete EntityPacketMsg_reflection_;
  delete ExploitOnMsg::default_instance_;
  delete ExploitOnMsg_reflection_;
  delete SharedESPUpdate::default_instance_;
  delete SharedESPUpdate_reflection_;
  delete HitBoxMsg::default_instance_;
  delete HitBoxMsg_reflection_;
  delete OriginUpdate::default_instance_;
  delete OriginUpdate_reflection_;
  delete HarpoonChat::default_instance_;
  delete HarpoonChat_reflection_;
}

void protobuf_AddDesc_CrossCheatTalkMessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\034CrossCheatTalkMessages.proto\",\n\tVector"
    "Msg\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\"8\n\021"
    "CrossCheatInitMsg\022\017\n\007SteamID\030\001 \001(\r\022\022\n\nSt"
    "eamIndex\030\002 \001(\r\"\264\001\n\017EntityPacketMsg\022\t\n\001x\030"
    "\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\022\017\n\007SteamID\030\004"
    " \001(\r\022\023\n\013ServerIndex\030\005 \001(\r\022\024\n\014PlayerHealt"
    "h\030\006 \001(\r\022\024\n\014PlayerArmour\030\007 \001(\r\022\032\n\006Origin\030"
    "\010 \001(\0132\n.VectorMsg\022\022\n\nMatrixData\030\t \001(\t\">\n"
    "\014ExploitOnMsg\022\n\n\002On\030\001 \001(\010\022\r\n\005Speed\030\002 \001(\r"
    "\022\023\n\013TickStarted\030\003 \001(\r\"4\n\017SharedESPUpdate"
    "\022!\n\007EntInfo\030\001 \003(\0132\020.EntityPacketMsg\"]\n\tH"
    "itBoxMsg\022\030\n\004Mins\030\001 \002(\0132\n.VectorMsg\022\030\n\004Ma"
    "xs\030\002 \002(\0132\n.VectorMsg\022\014\n\004Bone\030\003 \002(\r\022\016\n\006Ra"
    "dius\030\004 \002(\002\"\256\001\n\014OriginUpdate\022\017\n\007steamID\030\001"
    " \002(\r\022\t\n\001x\030\002 \002(\002\022\t\n\001y\030\003 \002(\002\022\t\n\001z\030\004 \002(\002\022\035\n"
    "\tEyeAngles\030\005 \002(\0132\n.VectorMsg\022\037\n\013EyePosit"
    "ion\030\006 \002(\0132\n.VectorMsg\022\016\n\006Matrix\030\007 \001(\014\022\034\n"
    "\010Hitboxes\030\010 \003(\0132\n.HitBoxMsg\"I\n\013HarpoonCh"
    "at\022\017\n\007steamID\030\001 \002(\r\022\r\n\005index\030\002 \002(\r\022\014\n\004Na"
    "me\030\003 \002(\t\022\014\n\004Text\030\004 \002(\t*\225\001\n\021CrossCheatMsg"
    "Type\022\027\n\023k_CrossCheatInitMsg\020\001\022\025\n\021k_Entit"
    "yPacketMsg\020\002\022\022\n\016k_ExploitOnMsg\020\003\022\025\n\021k_Sh"
    "aredESPUpdate\020\004\022\022\n\016k_OriginUpdate\020\005\022\021\n\rk"
    "_HarpoonChat\020\006", 934);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CrossCheatTalkMessages.proto", &protobuf_RegisterTypes);
  VectorMsg::default_instance_ = new VectorMsg();
  CrossCheatInitMsg::default_instance_ = new CrossCheatInitMsg();
  EntityPacketMsg::default_instance_ = new EntityPacketMsg();
  ExploitOnMsg::default_instance_ = new ExploitOnMsg();
  SharedESPUpdate::default_instance_ = new SharedESPUpdate();
  HitBoxMsg::default_instance_ = new HitBoxMsg();
  OriginUpdate::default_instance_ = new OriginUpdate();
  HarpoonChat::default_instance_ = new HarpoonChat();
  VectorMsg::default_instance_->InitAsDefaultInstance();
  CrossCheatInitMsg::default_instance_->InitAsDefaultInstance();
  EntityPacketMsg::default_instance_->InitAsDefaultInstance();
  ExploitOnMsg::default_instance_->InitAsDefaultInstance();
  SharedESPUpdate::default_instance_->InitAsDefaultInstance();
  HitBoxMsg::default_instance_->InitAsDefaultInstance();
  OriginUpdate::default_instance_->InitAsDefaultInstance();
  HarpoonChat::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CrossCheatTalkMessages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CrossCheatTalkMessages_2eproto {
  StaticDescriptorInitializer_CrossCheatTalkMessages_2eproto() {
    protobuf_AddDesc_CrossCheatTalkMessages_2eproto();
  }
} static_descriptor_initializer_CrossCheatTalkMessages_2eproto_;
const ::google::protobuf::EnumDescriptor* CrossCheatMsgType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CrossCheatMsgType_descriptor_;
}
bool CrossCheatMsgType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int VectorMsg::kXFieldNumber;
const int VectorMsg::kYFieldNumber;
const int VectorMsg::kZFieldNumber;
#endif  // !_MSC_VER

VectorMsg::VectorMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VectorMsg::InitAsDefaultInstance() {
}

VectorMsg::VectorMsg(const VectorMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VectorMsg::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VectorMsg::~VectorMsg() {
  SharedDtor();
}

void VectorMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VectorMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VectorMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VectorMsg_descriptor_;
}

const VectorMsg& VectorMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkMessages_2eproto();
  return *default_instance_;
}

VectorMsg* VectorMsg::default_instance_ = NULL;

VectorMsg* VectorMsg::New() const {
  return new VectorMsg;
}

void VectorMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VectorMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VectorMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VectorMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VectorMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VectorMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VectorMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VectorMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VectorMsg::MergeFrom(const VectorMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VectorMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VectorMsg::CopyFrom(const VectorMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void VectorMsg::Swap(VectorMsg* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VectorMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VectorMsg_descriptor_;
  metadata.reflection = VectorMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CrossCheatInitMsg::kSteamIDFieldNumber;
const int CrossCheatInitMsg::kSteamIndexFieldNumber;
#endif  // !_MSC_VER

CrossCheatInitMsg::CrossCheatInitMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CrossCheatInitMsg::InitAsDefaultInstance() {
}

CrossCheatInitMsg::CrossCheatInitMsg(const CrossCheatInitMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CrossCheatInitMsg::SharedCtor() {
  _cached_size_ = 0;
  steamid_ = 0u;
  steamindex_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CrossCheatInitMsg::~CrossCheatInitMsg() {
  SharedDtor();
}

void CrossCheatInitMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CrossCheatInitMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CrossCheatInitMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CrossCheatInitMsg_descriptor_;
}

const CrossCheatInitMsg& CrossCheatInitMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkMessages_2eproto();
  return *default_instance_;
}

CrossCheatInitMsg* CrossCheatInitMsg::default_instance_ = NULL;

CrossCheatInitMsg* CrossCheatInitMsg::New() const {
  return new CrossCheatInitMsg;
}

void CrossCheatInitMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    steamid_ = 0u;
    steamindex_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CrossCheatInitMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 SteamID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &steamid_)));
          set_has_steamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_SteamIndex;
        break;
      }

      // optional uint32 SteamIndex = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SteamIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &steamindex_)));
          set_has_steamindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CrossCheatInitMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 SteamID = 1;
  if (has_steamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->steamid(), output);
  }

  // optional uint32 SteamIndex = 2;
  if (has_steamindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->steamindex(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CrossCheatInitMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 SteamID = 1;
  if (has_steamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->steamid(), target);
  }

  // optional uint32 SteamIndex = 2;
  if (has_steamindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->steamindex(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CrossCheatInitMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 SteamID = 1;
    if (has_steamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->steamid());
    }

    // optional uint32 SteamIndex = 2;
    if (has_steamindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->steamindex());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CrossCheatInitMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CrossCheatInitMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CrossCheatInitMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CrossCheatInitMsg::MergeFrom(const CrossCheatInitMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_steamid()) {
      set_steamid(from.steamid());
    }
    if (from.has_steamindex()) {
      set_steamindex(from.steamindex());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CrossCheatInitMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CrossCheatInitMsg::CopyFrom(const CrossCheatInitMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrossCheatInitMsg::IsInitialized() const {

  return true;
}

void CrossCheatInitMsg::Swap(CrossCheatInitMsg* other) {
  if (other != this) {
    std::swap(steamid_, other->steamid_);
    std::swap(steamindex_, other->steamindex_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CrossCheatInitMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CrossCheatInitMsg_descriptor_;
  metadata.reflection = CrossCheatInitMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EntityPacketMsg::kXFieldNumber;
const int EntityPacketMsg::kYFieldNumber;
const int EntityPacketMsg::kZFieldNumber;
const int EntityPacketMsg::kSteamIDFieldNumber;
const int EntityPacketMsg::kServerIndexFieldNumber;
const int EntityPacketMsg::kPlayerHealthFieldNumber;
const int EntityPacketMsg::kPlayerArmourFieldNumber;
const int EntityPacketMsg::kOriginFieldNumber;
const int EntityPacketMsg::kMatrixDataFieldNumber;
#endif  // !_MSC_VER

EntityPacketMsg::EntityPacketMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EntityPacketMsg::InitAsDefaultInstance() {
  origin_ = const_cast< ::VectorMsg*>(&::VectorMsg::default_instance());
}

EntityPacketMsg::EntityPacketMsg(const EntityPacketMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EntityPacketMsg::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  steamid_ = 0u;
  serverindex_ = 0u;
  playerhealth_ = 0u;
  playerarmour_ = 0u;
  origin_ = NULL;
  matrixdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EntityPacketMsg::~EntityPacketMsg() {
  SharedDtor();
}

void EntityPacketMsg::SharedDtor() {
  if (matrixdata_ != &::google::protobuf::internal::kEmptyString) {
    delete matrixdata_;
  }
  if (this != default_instance_) {
    delete origin_;
  }
}

void EntityPacketMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EntityPacketMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EntityPacketMsg_descriptor_;
}

const EntityPacketMsg& EntityPacketMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkMessages_2eproto();
  return *default_instance_;
}

EntityPacketMsg* EntityPacketMsg::default_instance_ = NULL;

EntityPacketMsg* EntityPacketMsg::New() const {
  return new EntityPacketMsg;
}

void EntityPacketMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
    steamid_ = 0u;
    serverindex_ = 0u;
    playerhealth_ = 0u;
    playerarmour_ = 0u;
    if (has_origin()) {
      if (origin_ != NULL) origin_->::VectorMsg::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_matrixdata()) {
      if (matrixdata_ != &::google::protobuf::internal::kEmptyString) {
        matrixdata_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EntityPacketMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_SteamID;
        break;
      }

      // optional uint32 SteamID = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SteamID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &steamid_)));
          set_has_steamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_ServerIndex;
        break;
      }

      // optional uint32 ServerIndex = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ServerIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serverindex_)));
          set_has_serverindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_PlayerHealth;
        break;
      }

      // optional uint32 PlayerHealth = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PlayerHealth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &playerhealth_)));
          set_has_playerhealth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_PlayerArmour;
        break;
      }

      // optional uint32 PlayerArmour = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PlayerArmour:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &playerarmour_)));
          set_has_playerarmour();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_Origin;
        break;
      }

      // optional .VectorMsg Origin = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Origin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_MatrixData;
        break;
      }

      // optional string MatrixData = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_MatrixData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_matrixdata()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->matrixdata().data(), this->matrixdata().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EntityPacketMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  // optional uint32 SteamID = 4;
  if (has_steamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->steamid(), output);
  }

  // optional uint32 ServerIndex = 5;
  if (has_serverindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->serverindex(), output);
  }

  // optional uint32 PlayerHealth = 6;
  if (has_playerhealth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->playerhealth(), output);
  }

  // optional uint32 PlayerArmour = 7;
  if (has_playerarmour()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->playerarmour(), output);
  }

  // optional .VectorMsg Origin = 8;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->origin(), output);
  }

  // optional string MatrixData = 9;
  if (has_matrixdata()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->matrixdata().data(), this->matrixdata().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->matrixdata(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EntityPacketMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  // optional uint32 SteamID = 4;
  if (has_steamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->steamid(), target);
  }

  // optional uint32 ServerIndex = 5;
  if (has_serverindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->serverindex(), target);
  }

  // optional uint32 PlayerHealth = 6;
  if (has_playerhealth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->playerhealth(), target);
  }

  // optional uint32 PlayerArmour = 7;
  if (has_playerarmour()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->playerarmour(), target);
  }

  // optional .VectorMsg Origin = 8;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->origin(), target);
  }

  // optional string MatrixData = 9;
  if (has_matrixdata()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->matrixdata().data(), this->matrixdata().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->matrixdata(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EntityPacketMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

    // optional uint32 SteamID = 4;
    if (has_steamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->steamid());
    }

    // optional uint32 ServerIndex = 5;
    if (has_serverindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serverindex());
    }

    // optional uint32 PlayerHealth = 6;
    if (has_playerhealth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->playerhealth());
    }

    // optional uint32 PlayerArmour = 7;
    if (has_playerarmour()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->playerarmour());
    }

    // optional .VectorMsg Origin = 8;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->origin());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string MatrixData = 9;
    if (has_matrixdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->matrixdata());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EntityPacketMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EntityPacketMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EntityPacketMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EntityPacketMsg::MergeFrom(const EntityPacketMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_steamid()) {
      set_steamid(from.steamid());
    }
    if (from.has_serverindex()) {
      set_serverindex(from.serverindex());
    }
    if (from.has_playerhealth()) {
      set_playerhealth(from.playerhealth());
    }
    if (from.has_playerarmour()) {
      set_playerarmour(from.playerarmour());
    }
    if (from.has_origin()) {
      mutable_origin()->::VectorMsg::MergeFrom(from.origin());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_matrixdata()) {
      set_matrixdata(from.matrixdata());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EntityPacketMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EntityPacketMsg::CopyFrom(const EntityPacketMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntityPacketMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_origin()) {
    if (!this->origin().IsInitialized()) return false;
  }
  return true;
}

void EntityPacketMsg::Swap(EntityPacketMsg* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(steamid_, other->steamid_);
    std::swap(serverindex_, other->serverindex_);
    std::swap(playerhealth_, other->playerhealth_);
    std::swap(playerarmour_, other->playerarmour_);
    std::swap(origin_, other->origin_);
    std::swap(matrixdata_, other->matrixdata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EntityPacketMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EntityPacketMsg_descriptor_;
  metadata.reflection = EntityPacketMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExploitOnMsg::kOnFieldNumber;
const int ExploitOnMsg::kSpeedFieldNumber;
const int ExploitOnMsg::kTickStartedFieldNumber;
#endif  // !_MSC_VER

ExploitOnMsg::ExploitOnMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ExploitOnMsg::InitAsDefaultInstance() {
}

ExploitOnMsg::ExploitOnMsg(const ExploitOnMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ExploitOnMsg::SharedCtor() {
  _cached_size_ = 0;
  on_ = false;
  speed_ = 0u;
  tickstarted_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExploitOnMsg::~ExploitOnMsg() {
  SharedDtor();
}

void ExploitOnMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ExploitOnMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExploitOnMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExploitOnMsg_descriptor_;
}

const ExploitOnMsg& ExploitOnMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkMessages_2eproto();
  return *default_instance_;
}

ExploitOnMsg* ExploitOnMsg::default_instance_ = NULL;

ExploitOnMsg* ExploitOnMsg::New() const {
  return new ExploitOnMsg;
}

void ExploitOnMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    on_ = false;
    speed_ = 0u;
    tickstarted_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExploitOnMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool On = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &on_)));
          set_has_on();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_Speed;
        break;
      }

      // optional uint32 Speed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_TickStarted;
        break;
      }

      // optional uint32 TickStarted = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TickStarted:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tickstarted_)));
          set_has_tickstarted();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExploitOnMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool On = 1;
  if (has_on()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->on(), output);
  }

  // optional uint32 Speed = 2;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->speed(), output);
  }

  // optional uint32 TickStarted = 3;
  if (has_tickstarted()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->tickstarted(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ExploitOnMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool On = 1;
  if (has_on()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->on(), target);
  }

  // optional uint32 Speed = 2;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->speed(), target);
  }

  // optional uint32 TickStarted = 3;
  if (has_tickstarted()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->tickstarted(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ExploitOnMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool On = 1;
    if (has_on()) {
      total_size += 1 + 1;
    }

    // optional uint32 Speed = 2;
    if (has_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->speed());
    }

    // optional uint32 TickStarted = 3;
    if (has_tickstarted()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tickstarted());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExploitOnMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExploitOnMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExploitOnMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExploitOnMsg::MergeFrom(const ExploitOnMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_on()) {
      set_on(from.on());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_tickstarted()) {
      set_tickstarted(from.tickstarted());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExploitOnMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExploitOnMsg::CopyFrom(const ExploitOnMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExploitOnMsg::IsInitialized() const {

  return true;
}

void ExploitOnMsg::Swap(ExploitOnMsg* other) {
  if (other != this) {
    std::swap(on_, other->on_);
    std::swap(speed_, other->speed_);
    std::swap(tickstarted_, other->tickstarted_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExploitOnMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExploitOnMsg_descriptor_;
  metadata.reflection = ExploitOnMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SharedESPUpdate::kEntInfoFieldNumber;
#endif  // !_MSC_VER

SharedESPUpdate::SharedESPUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SharedESPUpdate::InitAsDefaultInstance() {
}

SharedESPUpdate::SharedESPUpdate(const SharedESPUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SharedESPUpdate::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SharedESPUpdate::~SharedESPUpdate() {
  SharedDtor();
}

void SharedESPUpdate::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SharedESPUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SharedESPUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SharedESPUpdate_descriptor_;
}

const SharedESPUpdate& SharedESPUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkMessages_2eproto();
  return *default_instance_;
}

SharedESPUpdate* SharedESPUpdate::default_instance_ = NULL;

SharedESPUpdate* SharedESPUpdate::New() const {
  return new SharedESPUpdate;
}

void SharedESPUpdate::Clear() {
  entinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SharedESPUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .EntityPacketMsg EntInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_EntInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_EntInfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SharedESPUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .EntityPacketMsg EntInfo = 1;
  for (int i = 0; i < this->entinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entinfo(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SharedESPUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .EntityPacketMsg EntInfo = 1;
  for (int i = 0; i < this->entinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entinfo(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SharedESPUpdate::ByteSize() const {
  int total_size = 0;

  // repeated .EntityPacketMsg EntInfo = 1;
  total_size += 1 * this->entinfo_size();
  for (int i = 0; i < this->entinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entinfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SharedESPUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SharedESPUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SharedESPUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SharedESPUpdate::MergeFrom(const SharedESPUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  entinfo_.MergeFrom(from.entinfo_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SharedESPUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SharedESPUpdate::CopyFrom(const SharedESPUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SharedESPUpdate::IsInitialized() const {

  for (int i = 0; i < entinfo_size(); i++) {
    if (!this->entinfo(i).IsInitialized()) return false;
  }
  return true;
}

void SharedESPUpdate::Swap(SharedESPUpdate* other) {
  if (other != this) {
    entinfo_.Swap(&other->entinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SharedESPUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SharedESPUpdate_descriptor_;
  metadata.reflection = SharedESPUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HitBoxMsg::kMinsFieldNumber;
const int HitBoxMsg::kMaxsFieldNumber;
const int HitBoxMsg::kBoneFieldNumber;
const int HitBoxMsg::kRadiusFieldNumber;
#endif  // !_MSC_VER

HitBoxMsg::HitBoxMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HitBoxMsg::InitAsDefaultInstance() {
  mins_ = const_cast< ::VectorMsg*>(&::VectorMsg::default_instance());
  maxs_ = const_cast< ::VectorMsg*>(&::VectorMsg::default_instance());
}

HitBoxMsg::HitBoxMsg(const HitBoxMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HitBoxMsg::SharedCtor() {
  _cached_size_ = 0;
  mins_ = NULL;
  maxs_ = NULL;
  bone_ = 0u;
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HitBoxMsg::~HitBoxMsg() {
  SharedDtor();
}

void HitBoxMsg::SharedDtor() {
  if (this != default_instance_) {
    delete mins_;
    delete maxs_;
  }
}

void HitBoxMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HitBoxMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HitBoxMsg_descriptor_;
}

const HitBoxMsg& HitBoxMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkMessages_2eproto();
  return *default_instance_;
}

HitBoxMsg* HitBoxMsg::default_instance_ = NULL;

HitBoxMsg* HitBoxMsg::New() const {
  return new HitBoxMsg;
}

void HitBoxMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mins()) {
      if (mins_ != NULL) mins_->::VectorMsg::Clear();
    }
    if (has_maxs()) {
      if (maxs_ != NULL) maxs_->::VectorMsg::Clear();
    }
    bone_ = 0u;
    radius_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HitBoxMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .VectorMsg Mins = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mins()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Maxs;
        break;
      }

      // required .VectorMsg Maxs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Maxs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_maxs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Bone;
        break;
      }

      // required uint32 Bone = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Bone:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bone_)));
          set_has_bone();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_Radius;
        break;
      }

      // required float Radius = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HitBoxMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .VectorMsg Mins = 1;
  if (has_mins()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->mins(), output);
  }

  // required .VectorMsg Maxs = 2;
  if (has_maxs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->maxs(), output);
  }

  // required uint32 Bone = 3;
  if (has_bone()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->bone(), output);
  }

  // required float Radius = 4;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->radius(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HitBoxMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .VectorMsg Mins = 1;
  if (has_mins()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->mins(), target);
  }

  // required .VectorMsg Maxs = 2;
  if (has_maxs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->maxs(), target);
  }

  // required uint32 Bone = 3;
  if (has_bone()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->bone(), target);
  }

  // required float Radius = 4;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->radius(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HitBoxMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .VectorMsg Mins = 1;
    if (has_mins()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mins());
    }

    // required .VectorMsg Maxs = 2;
    if (has_maxs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->maxs());
    }

    // required uint32 Bone = 3;
    if (has_bone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bone());
    }

    // required float Radius = 4;
    if (has_radius()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HitBoxMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HitBoxMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HitBoxMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HitBoxMsg::MergeFrom(const HitBoxMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mins()) {
      mutable_mins()->::VectorMsg::MergeFrom(from.mins());
    }
    if (from.has_maxs()) {
      mutable_maxs()->::VectorMsg::MergeFrom(from.maxs());
    }
    if (from.has_bone()) {
      set_bone(from.bone());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HitBoxMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HitBoxMsg::CopyFrom(const HitBoxMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HitBoxMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_mins()) {
    if (!this->mins().IsInitialized()) return false;
  }
  if (has_maxs()) {
    if (!this->maxs().IsInitialized()) return false;
  }
  return true;
}

void HitBoxMsg::Swap(HitBoxMsg* other) {
  if (other != this) {
    std::swap(mins_, other->mins_);
    std::swap(maxs_, other->maxs_);
    std::swap(bone_, other->bone_);
    std::swap(radius_, other->radius_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HitBoxMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HitBoxMsg_descriptor_;
  metadata.reflection = HitBoxMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OriginUpdate::kSteamIDFieldNumber;
const int OriginUpdate::kXFieldNumber;
const int OriginUpdate::kYFieldNumber;
const int OriginUpdate::kZFieldNumber;
const int OriginUpdate::kEyeAnglesFieldNumber;
const int OriginUpdate::kEyePositionFieldNumber;
const int OriginUpdate::kMatrixFieldNumber;
const int OriginUpdate::kHitboxesFieldNumber;
#endif  // !_MSC_VER

OriginUpdate::OriginUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void OriginUpdate::InitAsDefaultInstance() {
  eyeangles_ = const_cast< ::VectorMsg*>(&::VectorMsg::default_instance());
  eyeposition_ = const_cast< ::VectorMsg*>(&::VectorMsg::default_instance());
}

OriginUpdate::OriginUpdate(const OriginUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void OriginUpdate::SharedCtor() {
  _cached_size_ = 0;
  steamid_ = 0u;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  eyeangles_ = NULL;
  eyeposition_ = NULL;
  matrix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OriginUpdate::~OriginUpdate() {
  SharedDtor();
}

void OriginUpdate::SharedDtor() {
  if (matrix_ != &::google::protobuf::internal::kEmptyString) {
    delete matrix_;
  }
  if (this != default_instance_) {
    delete eyeangles_;
    delete eyeposition_;
  }
}

void OriginUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OriginUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OriginUpdate_descriptor_;
}

const OriginUpdate& OriginUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkMessages_2eproto();
  return *default_instance_;
}

OriginUpdate* OriginUpdate::default_instance_ = NULL;

OriginUpdate* OriginUpdate::New() const {
  return new OriginUpdate;
}

void OriginUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    steamid_ = 0u;
    x_ = 0;
    y_ = 0;
    z_ = 0;
    if (has_eyeangles()) {
      if (eyeangles_ != NULL) eyeangles_->::VectorMsg::Clear();
    }
    if (has_eyeposition()) {
      if (eyeposition_ != NULL) eyeposition_->::VectorMsg::Clear();
    }
    if (has_matrix()) {
      if (matrix_ != &::google::protobuf::internal::kEmptyString) {
        matrix_->clear();
      }
    }
  }
  hitboxes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OriginUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 steamID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &steamid_)));
          set_has_steamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_x;
        break;
      }

      // required float x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_y;
        break;
      }

      // required float y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_z;
        break;
      }

      // required float z = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_EyeAngles;
        break;
      }

      // required .VectorMsg EyeAngles = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_EyeAngles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_eyeangles()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_EyePosition;
        break;
      }

      // required .VectorMsg EyePosition = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_EyePosition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_eyeposition()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_Matrix;
        break;
      }

      // optional bytes Matrix = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Matrix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_matrix()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_Hitboxes;
        break;
      }

      // repeated .HitBoxMsg Hitboxes = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Hitboxes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_hitboxes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_Hitboxes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OriginUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 steamID = 1;
  if (has_steamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->steamid(), output);
  }

  // required float x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x(), output);
  }

  // required float y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->y(), output);
  }

  // required float z = 4;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->z(), output);
  }

  // required .VectorMsg EyeAngles = 5;
  if (has_eyeangles()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->eyeangles(), output);
  }

  // required .VectorMsg EyePosition = 6;
  if (has_eyeposition()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->eyeposition(), output);
  }

  // optional bytes Matrix = 7;
  if (has_matrix()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->matrix(), output);
  }

  // repeated .HitBoxMsg Hitboxes = 8;
  for (int i = 0; i < this->hitboxes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->hitboxes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* OriginUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 steamID = 1;
  if (has_steamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->steamid(), target);
  }

  // required float x = 2;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x(), target);
  }

  // required float y = 3;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->y(), target);
  }

  // required float z = 4;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->z(), target);
  }

  // required .VectorMsg EyeAngles = 5;
  if (has_eyeangles()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->eyeangles(), target);
  }

  // required .VectorMsg EyePosition = 6;
  if (has_eyeposition()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->eyeposition(), target);
  }

  // optional bytes Matrix = 7;
  if (has_matrix()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->matrix(), target);
  }

  // repeated .HitBoxMsg Hitboxes = 8;
  for (int i = 0; i < this->hitboxes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->hitboxes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int OriginUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 steamID = 1;
    if (has_steamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->steamid());
    }

    // required float x = 2;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 3;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float z = 4;
    if (has_z()) {
      total_size += 1 + 4;
    }

    // required .VectorMsg EyeAngles = 5;
    if (has_eyeangles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->eyeangles());
    }

    // required .VectorMsg EyePosition = 6;
    if (has_eyeposition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->eyeposition());
    }

    // optional bytes Matrix = 7;
    if (has_matrix()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->matrix());
    }

  }
  // repeated .HitBoxMsg Hitboxes = 8;
  total_size += 1 * this->hitboxes_size();
  for (int i = 0; i < this->hitboxes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->hitboxes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OriginUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OriginUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OriginUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OriginUpdate::MergeFrom(const OriginUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  hitboxes_.MergeFrom(from.hitboxes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_steamid()) {
      set_steamid(from.steamid());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_eyeangles()) {
      mutable_eyeangles()->::VectorMsg::MergeFrom(from.eyeangles());
    }
    if (from.has_eyeposition()) {
      mutable_eyeposition()->::VectorMsg::MergeFrom(from.eyeposition());
    }
    if (from.has_matrix()) {
      set_matrix(from.matrix());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OriginUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OriginUpdate::CopyFrom(const OriginUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OriginUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_eyeangles()) {
    if (!this->eyeangles().IsInitialized()) return false;
  }
  if (has_eyeposition()) {
    if (!this->eyeposition().IsInitialized()) return false;
  }
  for (int i = 0; i < hitboxes_size(); i++) {
    if (!this->hitboxes(i).IsInitialized()) return false;
  }
  return true;
}

void OriginUpdate::Swap(OriginUpdate* other) {
  if (other != this) {
    std::swap(steamid_, other->steamid_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(eyeangles_, other->eyeangles_);
    std::swap(eyeposition_, other->eyeposition_);
    std::swap(matrix_, other->matrix_);
    hitboxes_.Swap(&other->hitboxes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OriginUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OriginUpdate_descriptor_;
  metadata.reflection = OriginUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HarpoonChat::kSteamIDFieldNumber;
const int HarpoonChat::kIndexFieldNumber;
const int HarpoonChat::kNameFieldNumber;
const int HarpoonChat::kTextFieldNumber;
#endif  // !_MSC_VER

HarpoonChat::HarpoonChat()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HarpoonChat::InitAsDefaultInstance() {
}

HarpoonChat::HarpoonChat(const HarpoonChat& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HarpoonChat::SharedCtor() {
  _cached_size_ = 0;
  steamid_ = 0u;
  index_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HarpoonChat::~HarpoonChat() {
  SharedDtor();
}

void HarpoonChat::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (this != default_instance_) {
  }
}

void HarpoonChat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HarpoonChat::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HarpoonChat_descriptor_;
}

const HarpoonChat& HarpoonChat::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkMessages_2eproto();
  return *default_instance_;
}

HarpoonChat* HarpoonChat::default_instance_ = NULL;

HarpoonChat* HarpoonChat::New() const {
  return new HarpoonChat;
}

void HarpoonChat::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    steamid_ = 0u;
    index_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HarpoonChat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 steamID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &steamid_)));
          set_has_steamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_index;
        break;
      }

      // required uint32 index = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_Name;
        break;
      }

      // required string Name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_Text;
        break;
      }

      // required string Text = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HarpoonChat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 steamID = 1;
  if (has_steamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->steamid(), output);
  }

  // required uint32 index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->index(), output);
  }

  // required string Name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->name(), output);
  }

  // required string Text = 4;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->text(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HarpoonChat::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 steamID = 1;
  if (has_steamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->steamid(), target);
  }

  // required uint32 index = 2;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->index(), target);
  }

  // required string Name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  // required string Text = 4;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->text(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HarpoonChat::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 steamID = 1;
    if (has_steamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->steamid());
    }

    // required uint32 index = 2;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // required string Name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required string Text = 4;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HarpoonChat::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HarpoonChat* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HarpoonChat*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HarpoonChat::MergeFrom(const HarpoonChat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_steamid()) {
      set_steamid(from.steamid());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_text()) {
      set_text(from.text());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HarpoonChat::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HarpoonChat::CopyFrom(const HarpoonChat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HarpoonChat::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void HarpoonChat::Swap(HarpoonChat* other) {
  if (other != this) {
    std::swap(steamid_, other->steamid_);
    std::swap(index_, other->index_);
    std::swap(name_, other->name_);
    std::swap(text_, other->text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HarpoonChat::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HarpoonChat_descriptor_;
  metadata.reflection = HarpoonChat_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
